### 1장 개요

- 스레드를 이용해 여러 작업을 동시에 실행하는 프로그램을 제대로 돌아가게 작성하긴 어렵다. 잘 공부해보자.

### 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사

- 운영체제가 여러 프로그램을 동시에 실행하는 방향으로 발전한 이유
    - 자원 활용: 입출력 같은 외부 동작이 끝나기를 기다려야 하는데 이 때 다른 일을 처리하지 못한다. 따라서 하나의 프로그램을 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적이다.
    - 공정성: 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하는 것보다 더 작은 단위로 컴퓨터를 공유하는 방법이 더 바람직하다.
    - 편의성: 각기 일을 하나씩 처리하는 것보다 필요할 때 프로그램 간 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직하다.

- 대부분의 언어는 순차적 프로그래밍 방식으로 실행된다.
- 한 프로세스 내에 스레드로 인해 여러 프로그램 제어 흐름이 공존할 수 있다.
    - 프로그램을 스레드로 분리해 하드웨어 병렬성을 이용할 수 있다. 즉, 한 프로그램 내 여러 스레드를 동시에 여러 개의 CPU에 할당해 실행시킬 수 있다.

- 스레드: lightweight process
    - 현대 OS의 대부분은 CPU 자원 스케줄을 정할 때, 스레드를 기본 단위로 한다.
    - 스레드는 프로세스에 할당된 자원을 공유하면서 각 스레드 별로 PC, stack, 지역 변수를 갖는다. 프로세스 내의 스레드는 같은 메모리 주소 공간을 공유하는데, 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙에 객체를 할당한다.
    - 프로세스는 더 세밀한 단위로 데이터를 공유할 수 있으나, 동기화가 적절하게 이뤄지지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수도 있다.

### 1.2 스레드의 이점

- GUI 애플리케이션에서 사용자 인터페이스의 반응률에 도움을 줌

- JVM을 더 단순하게 구현할 수 있게 도와줌
    - 가비지 컬렉터는 보통 하나 또는 두 개 이상의 전용 스레드에서 실행된다. 아주 단순한 자바 앱이 아닌 이상 어느 정도 여러 개의 스레드를 사용한다.

- 멀티프로세서 활용
    - 프로세서 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다. 프로세서가 2개인 시스템에서 스레드가 1개뿐이라면 CPU 자원의 50%를 낭비하는 셈이다.
    - 가용한 프로세서 자원을 더 효율적으로 이용해서 처리속도를 높일 수 있다.
        - 서버 애플리케이션에서 자원 활용도와 처리율을 높여줌

- 단순한 모델링
    - 여러 종류의 일을 각 스레드 별로 할당해서 특정한 일만 처리하도록 프로그래밍해서 세부적인 부분과 상위 비즈니스 로직을 분리할 수 있다.
    - 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 단순하고 동기적인 작업 흐름 몇 개로 나눌 수 있다.
        - 이 작업 흐름에선 특정한 동기화 시점에서만 상호 작용이 발생한다.
    - 서블릿, RMI 같은 프레임워크에선 요청 관리 / 스레드 생성 / 로드 밸런싱 / 작업 흐름 내에 적절한 시점에 적절한 애플리케이션 컴포넌트에 요청을 분배하는 작업 등의 상세한 부분을 처리한다. 서블릿 개발자는 동시에 다른 요청이 얼마나 많이 처리되고 있는지 등에 대해 걱정할 필요 없다.

- 단순한 비동기 이벤트 처리
    - 단일 스레드 서버 프로그램이라면 넌블로킹 IO를 써야 한다. 하지만 각 요청을 별개 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는 데는 별 영향을 끼치지 않는다.
    - 운영체제에서는 유닉스 시스템의 select나 poll 시스템 콜처럼 효율적인 다중화 IO 수단을 개발했고, 표준 자바 API에도 대기 상태에 들어가지 않는 IO를 지원할 수 있도록 java.nio 같은 패키지가 추가됐다. → 운영체제에서 더 많은 스레드를 지원할 수 있게 됌

- 더 빨리 반응하는 사용자 인터페이스
    - 이벤트 스레드에서 짧은 작업만 실행한다면, 이벤트 스레드가 빨리 처리할 수 있어 사용자 인터페이스 반응 속도에는 별 영향이 없으나 오래 걸리는 작업을 실행하면 속도가 떨어진다.
    - 시간이 오래 걸리는 작업을 별도의 스레드에서 실행 했다면 이벤트 스레드는 계속 UI 이벤트를 처리할 수 있어 UI가 더 빨리 반응할 수 있다.

### 1.3 스레드 사용의 위험성

- 안전성 위해 요소
    - 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산 순서가 예측하기 매우 어렵다.
    - 동기화가 되어 있지 않은 경우, 실행 과정에서 연산이 어떻게 서로를 간섭하느냐에 따라 결과가 달라질 수 있기 때문에 위험 요소가 된다.
    - 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수 있어 편리하나 데이터가 예측 못한 시점에 변경될 수 있는 가능성도 그만큼 크다.
    - 이를 조율하기 위해 자바에서는 공유 변수 접근을 조율하기 위한 동기화 수단을 제공된다. 동기화를 하지 않으면 컴파일러, 하드웨어, 실행 환경 각각에서 명령어의 실행 시점이나 실행 순서를 상당히 자유롭게 조정할 수 있다. 하지만 조정 하면서 최적화 하다 보면 스레드간 데이터 공유되고 있는지 명확히 구분해줘야 하는 부담이 생긴다.

- 활동성 위험
    - 안전성은 “잘못된 일이 생기지 않는다”
    - 활동성은 “원하는 일이 결국 일어난다”는 보완적인 목표
        - 예를 들어, 스레드 A에서 스레드 B가 독접하는 자원을 기다리고 있는데 스레드 B가 해당 자원을 절대 놓지 않으면, 스레드 A는 영영 기다리기만 하고 실행되지 않을 것이다. ← 활동성 장애

- 성능 위험
    - 멀티스레드 프로그램은 단일 스레드 프로그램에서 발생할 수 있는 성능 위험 + 스레드를 사용하기 때문에 생기는 추가적인 추가 위험에도 노출된다.
    - 스레드를 사용하면 생기는 부담
        - 더 빈번한 컨텍스트 스위칭
            - 실행중인 컨텍스트를 저장하고 다시 읽어들이고, 메모리를 읽고 쓰는데 지역성(locality)이 손실되고, CPU 시간을 스케줄링하는 데 소모해야 함
        - 동기화 수단의 사용
            - 컴파일러 최적화를 방해
            - 메모리 캐시를 지우거나 무효화하기도 함
        - 공유 메모리 버스에 동기화 관련 트래픽 유발

### 1.4 스레드는 어디에나

- 모든 자바 프로그램은 기본적으로 스레드를 사용한다. JVM을 시작시키면 main 메소드를 실행할 주 스레드 뿐 아니라 가비지 컬렉션이나 객체 종료(object finalization)와 같은 JVM 내부 작업을 담당할 스레드도 생성한다.
- 프레임워크는 스레드를 생성해 컴포넌트를 호출한다. 프레임워크 때문에 프로그램이 병렬로 실행되는 경우가 생기면 병렬로 실행된다는 사실을 프레임워크 뿐만 아니라 프로그램에서도 인식하고 적절히 대응해야 한다. 컴포넌트가 실행되는 과정에서 접근하는 코드 경로에 포함된 컴포넌트는 모두 스레드에 안전해야 한다.(스레드 안전성에는 전염성이 있다.)

- 아래는 모두 프로그램이 관리하지 않는 외부의 스레드에서 프로그램 코드를 호출한다.
    - 타이머: TimerTask가 접근하는 객체 자체를 스레드에 안전하게 만들어야 함
    - 서블릿과 JSP
        - 서블릿은 여러 스레드에서 동시에 호출될 수 있도록 작성돼야 한다. 즉, 서블릿은 스레드에 안전해야 한다.
        - 서블릿은 프로그램 범위(application scoped) 객체(ServletContext)나 세션 범위(session-scoped) 객체(클라이언트별 HttpSession)처럼 다른 서블릿과 공유하는 상태 정보에 접근할 때도 있다. 서블릿이 서블릿 간 혹은 요청들 간에 공유되는 객체에 접근할 때는 적절한 동기화 작업이 필요하다. 여러 요청 내에서 각기 다른 스레드로 동시에 접근하고 있을 수도 있기 때문이다.
        - 서블릿 필터나 ServletContext, HttpSession 같은 범위가 정해진 컨테이너에 저장된 객체 뿐 아니라 서블릿과 JSP 자체도 스레드에 안전해야 한다.
    - 원격 메소드 호출(Remote Method Invocation, RMI)
        - RMI는 다른 JVM에서 실행 중인 객체의 메소드를 호출할 수 있게 해준다. RMI로 원격 메소드를 호출하면 메소드 인자는 바이트 스트림으로 변환(marshaled)되고 네트워크를 통해 원격 JVM으로 전달된다.
        - 원격 JVM에선 원래되로 변환되어(unmarcharled) 원격 메소드에 인자로 전달된다.
        - RMI는 다른 객체와 공유될 수 있는 상태에 접근할 때 / 원격 객체 자체의 상태에 접근할 때 스레드에 안전해야 한다.
    - 스윙, AWT
        - GUI는 본질적으로 비동기적으로 동작한다.
        - 스윙, AWT는 사용자가 발생시킨 이벤트를 처리하거나 사용자가 보는 그래픽을 갱신하기 위해 별도 스레드를 생성해 작업을 맡긴다.
        - 이벤트 스레드 밖에서 GUI를 다룬다면 GUI를 다루는 코드가 해당 외부 스레드 대신 이벤트 스레드에서 실행되게 해야 한다.

### 2장 스레드 안전성

- 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것이다.
- 공유됐다 → 여러 스레드가 특정 변수에 접근할 수 있다.
- 변경할 수 있다(mutable) → 해당 변수 값이 변경될 수 있다는 뜻이다.
- 스레드 안정성은 코드를 보호하는 게 아니라, **데이터에 제어 없이 동시 접근하는 걸 막으려는 의미**
- 스레드가 하나 이상 변수에 접근하고 + 변수에 값을 쓰면 → 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율해야 한다.
- 🌟 어떤 스레드가 변경할 수 있는 상태 변수를 적절한 동기화 없이 접근한다면 그 프로그램은 잘못됐다. 이런 문제를 해결하는 3가지 방법이 있다.
    - 변수를 스레드 간에 공유하지 않는다. (스택에 저장된 변수 접근 등)
    - 변수를 변경할 수 없도록 만든다.
    - 접근할 땐 언제나 동기화를 사용한다.

## 스레드 안전성이란?

- 여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 안전하다.
- 🌟 스레드 안전한 클래스?
    - 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화
- 🌟 상태 없는 객체는 항상 스레드 안전하다.
    - 스레드 간 상태를 공유하지 않으면 다른 스레드의 결과에 영향을 주지 않는다.

## 단일 연산

- 현재 값을 가져오고, 그 값에 1을 더하고, 새 값을 저장하는 총 3가지 작업이 순차적으로 실행
- 여러 스레드가 동시에 값을 참조할 때, 타이밍 문제가 발생가능 → 경쟁 조건

### 경쟁 조건 (race condition)

- 타이밍이 딱 맞았을 때만 정답을 얻는 경우
- 경쟁 조건 형태
    - 점검 후 행동 (check-then-act)
        - 여러 가지 사건의 상대적인 시점에 따라 원하는 결과를 얻을 수도 얻지 못할 수도 있음
        - 관찰 결과의 무효화, 즉 잠재적으로 유효하지 않은 관찰 결과로 결정을 내리거나 계산하는 것
        - e.g. 파일 X 가 없음을 확인하고 파일 X를 생성한다. 하지만 그 사이에 다른 누군가가 파일 X를 이미 생성했을 수 있다. 이런 경우 문제가 발생한다.
        - ex) lazy initialization
            - 실제 클래스를 사용할 때, 딱 1번만 초기화되어 항상 같은 인스턴스를 리턴하도록 설계를 했지만, 스레드 별로 getInstance()를 호출한 타이밍에 따라 호출한 각각의 스레드가 모두 서로 다른 인스턴스를 가질 수 있음
    - 읽고 수정하고 쓰기 (read-modify-write)
        - 이전 상태 기준으로 객체의 상태를 변경한다.
            
            ```java
            ++count;
            ```
            
- 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 한다.
    - 다른 스레드는 수정 도중에 해당 변수에 접근할 수 없다. 즉, 수정 이전이나 이후에만 상태를 읽거나 변경할 수 있다는 뜻이다.

### 복합 동작 (compound action)

- 스레드 안전성을 보장하기 위해서는 점검 후 행동 (check-then-act), 읽고 수정하고 쓰기 (read-modify-write) 동작이 항상 단일 연산이어야 한다.
- 위와 같은 동작을 복합 동작이라고 한다.
- 복합 동작 → 스레드에 안전하기 위해서는 전체가 단일 연산으로 실행돼야 하는 일련의 동작
    - 연산의 단일성을 보장하기 위한 도구 → 락

## 락 (lock)

- 여러 개의 변수가 하나의 불변조건을 구성하고 있다면, 이 변수들은 서로 독립적이지 않다.
- 각 변수들 그 자체로 스레드 안전하다고 해서 전체 클래스의 상태가 안전하지는 않다는 뜻이다.
- 🌟 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 한다.

### 암묵적인 락

- synchronized 구문
- 자바에 내장된 락을 암묵적인 락(intrinsic lock) 혹은 모니터 락(monitor lock)이라고 한다.
- 락은
    - 스레드가 synchronized 블록에 들어가기 전에 자동 확보
    - 정상적으로든 예외가 발생하든 해당 블록을 벗어날 때 자동으로 해제된다.
- 🌟 한 번에 한 스레드만 특정 락을 소유할 수 있다.
- 🌟 특정 락으로 보호된 코드 블록은 한 번에 한 스레드만 실행할 수 있다.

### 재진입성 (reentrant)

- 재진입성 → 스레드 단위로 락을 얻는다
    - 락이 있으면 1, 없으면 0으로 JVM이 확보 횟수를 지정
    - 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있다.
        - synchronized 구문이 있는 하위 클래스에서 synchronized이 있는 상위 클래스의 메소드를 호출한 경우에도 데드락에 걸리지 않음

## 락으로 상태 보호하기

- 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 한다.
- 따라서 공유된 상태에 한 시점에 오직 한 스레드만 접근할 수 있도록 보장하는 규칙을 만들 때 유용하다.
- 락을 활용하는 일반적인 사용 예는
    1. 모든 변경 가능한 변수를 객체 안에 캡슐화
    2. 암묵적인 락을 사용, 해당 변수에 접근하는 모든 코드 경로를 동기화함
    3. 객체 상태 나타내는 모든 변수는 객체의 암묵적인 락으로 보호
- 🌟 여러 변수에 대한 불변조건이 있으면, 해당 변수들은 모두 같은 락으로 보호해야 한다.

## 활동성과 성능

<img width="1413" alt="image" src="https://github.com/JAVACAFE-STUDY/java-thread-and-memory-deep-dive-2024/assets/84627144/c9bdf570-75a3-4dc8-9b14-91494e186e6d">

- 🌟 synchronized 블록의 범위를 스레드 안정성을 유지할 정도로만 최소로 잡자.
    - 블록 안의 코드가 무엇을 하는지, 얼마나 걸릴지 파악해야한다.
    - 락을 오래 잡고 있으면 활동성이나 성능 문제를 야기한다.
- 🌟 복잡하고 오래 걸리는 계산, 네트웍 작업, 사용자 입출력 작업과 같이 오래 걸리는 부분은 가능한 락을 잡지 말자.

### 3장 객체 공유

- 여러 개의 스레드에서 객체를 동시에 사용하려 할 때 섞이지 않고 안전하게 동작하도록
- 객체를 공유하고 공개하는 방법을 살핀다.
- 크리티컬 섹션?
- 코드 블록을 동기화할 때 항상 메모리 가시성(Memory Visibility) 문제가 발생한다.
- 반드시 달성돼야 하는 거
    - 변수를 사용하고 있을 때 다른 스레드가 해당 변수 값을 사용하지 못하도록 막아야한다.
    - 동기화 블록을 빠져나가고 나면 다른 스레드가 변경된 값을 즉시 사용할 수 있어야한다.

## 가시성

- 변수에 값을 저장하고 이후에 값을 다시 읽으면, 아까 저장한 값을 가져올 수 있을거라고 예상한다.
- 하지만 멀티 스레드 환경에서는
    - 특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 없을 수 있다.
    - 심지어 값을 읽지 못할 수 있다.
- 🌟 메모리상 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야 한다.
- 재배치(reordering): 특정 메소드의 소스코드가 100% 코딩된 순서로 동작함을 보장할 수 없다.
    - 동기화를 지정하지 않으면 컴파일러나 프로세서, JVM이 프로그램 코드 실행 순서를 임의로 바꾸는 경우가 있다.
- 🌟 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용한다
- 스레드는 메모리를 공유하는데, 컴파일, 런타임 최적화 시점에 메모리 이외의 저장소를 활용할 수 있는게 원인인가? 프로세서 레지스터나 외부 캐시 등

### 스테일 데이터 (stale data)

- 변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우가 발생할 수 있다.
    - 다른 스레드에서 작성한 값을 가져갈 수 없기 때문에, 변수를 사용하려고 접근하기 전에 다른 스레드가 값을 갱신했다면, 이미 최신 값이 아닌 값으로 작업을 진행할 수 도 있다.

### 단일하지 않은 64비트 연산

- 숫자형에 volatile 키워드를 사용하지 않으면 난데없는 값이 들어갈 수도 있다.
- 64비트 값에 대해 메모리에 쓰거나 읽을 때 두 번의 32비트 연산을 할 수도 있기 때문…

### 락과 가시성

<img width="1413" alt="image" src="https://github.com/JAVACAFE-STUDY/java-thread-and-memory-deep-dive-2024/assets/84627144/f02dbb07-bbc5-4f4d-8944-999763aa7d78">

- synchronized로 둘러싸인 코드에서 스레드 A가 사용한 모든 변수 값은, 같은 락을 사용하는 스레드 B가 실행할 때 안전하게 사용할 수 있다.
- 🌟 락은 상호 배제뿐 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다.

### volatile 변수

- volatile 변수는 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해준다.
    - “이 변수는 공유해 사용하고, 실행 순서를 재배치 하지마”라고 컴파일러와 런타임에게 알린다.
- 프로세서의 레지스터에 캐시되지도 않고, 프로세서 외부의 캐시에도 들어가지 않기 때문에 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있다.
- 락이나 동기화 기능과는 다르다. volatile 지정은 락이나 동기화 기능이 동작하시키지 않는다.
- 메모리 가시성 입장에선 volatile이나 synchronized는 비슷한 효과를 가져온다.
- 🌟 락은 가시성 + 연산의 단일성 보장, volatile은 가시성만 보장
- 🌟 다음과 같은 경우만 사용하자.
    - 변수에 값을 저장하는 작업이 변수의 지금 값과 관련이 없는 경우
        - 연산의 단일성도 보장해야함.
    - 해당 변수의 값을 변경하는 스레드가 하나만 존재하는 경우
        - 변수 값 변경이 단일 스레드에서 진행되므로 동시성이 보장될 필요 없음.
    - 변수가 불변조건에 관련되어 있지 않은 경우
        - 동시성 보장이 필요없음
    - 변수를 사용하는 동안 어떤 경우라도 락을 걸어 둘 필요가 없는 경우 (?)

## 공개와 유출

- 공개(published) 되었다 → 어떤 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만듬
    - 이 경우에는 반드시 해당 객체를 동기화시켜야 한다.
- 유출 상태(escaped) → 의도적으로 공개하지 않았지만, 외부에서 사용할 수 있게 공개된 경우
    - 특정 객체를 공개 하면서, 그와 관련된 다른 객체까지 덩달아 공개하는 경우
    - 내부 클래스(inner 클래스)의 인스턴스를 외부에 공개하는 경우
        - 내부 클래스 인스턴스는 항상 outer class의 참조를 가지고 있다.
    - 생성 메소드 실행 도중에 this 변수가 외부에 공개되는 경우도 있다.
- 어떤 객체건 일단 유출되고 나면, 다른 스레드가 유출된 클래스를 잘못 사용할 수 있다고 가정해야함.
- 🌟 생성 메소드 실행 도중에 this가 외부에 유출되면 안된다.
    - this를 넘겨서 이벤트 등록하는 이벤트를 생각할 수 있는데 이벤트 등록을 생성자에서 하는게 아니라 팩토리 메서드를 만들어 사용할 수 있다.
    
    ```java
    // 생성자로 source를 받고 registerListener 코드를 등록하면// 무명 객체에 의해 부주의하게 this 참조가 유출되게 된다.classSafeListenerprivateconstructor() {
    val listener: EventListener =object : EventListener { .. }
    
    companionobject {
    funnewInstance(source:EventSource): SafeListener {
          safe = SafeListener()
          source.registerListener(safe.listener)
    return safe
        }
      }
    }
    
    ```
    

## 스레드 한정

- 모든 변경가능한 객체를 다룰 때 선택할 수 있는 전략은 두 가지다.
    1. 스레드간 공유하는 경우는 동기화
    2. 스레드간 공유하지 않음
- 2번 처럼, 객체를 사용하는 스레드를 한정(confine)하는 방법으로 스레드 안정성을 확보할 수 있다.
    - GUI 프로그래밍에선 이벤트 스레드를 제외한 다른 스레드에서 UI 객체를 사용할 수 없다.
- 스레드 한정 기법은 프로그램 처음 설계부터 다뤄야한다.
- 프로그램 구현 내내 한정 기법을 계속 적용해야한다.
- 이러한 기법을 사용해도, 개발자는 스레드에 한정된 객체가 외부로 유출되지 않도록 신경 써야 한다.

### 스레드 한정 - 주먹구구식

- GUI 모듈과 같은 특정 시스템을 단일 스레드로 동작하도록 만들 것이냐?
- 특정 스레드에 한정하려는 객체가 volatile로 선언되어 있다면?
    - volatile 변수는 단일 스레드에서만 쓰기 작업을 한다면, 읽기 작업은 멀티 스레드에서 접근해도 안전하다. (가장 최근에 업데이트된 값을 정확하게 읽어갈 수 있다.)

### 스택 한정

- 스택 한정 기법 → 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법
- 로컬 변수는 모두 암묵적으로 현재 실행 중인 스레드에 한정되어 있다고 볼 수 있다. (스레드마다 스택을 가지므로 스택에 저장되는 변수는 스레드에 한정될 것)
- reference 변수를 스택에 저장한다면, 그 객체에 대한 참조가 외부로 유출되지 않도록 개발자가 주의해야 한다. (객체의 참조는 힙, 즉 스레드 간 공유 영역에 존재하므로)
- 스레드에 안전하지 않은 객체라도 특정 스레드 내부에서만 사용한다면 동기화 문제는 없다. 안전하다.

### ThreadLocal

- 호출하는 스레드마다 다른 값을 사용할 수 있도록 관리
- ThreadLocal의 get메서드를 호출하면, 현재 실행 중인 스레드에서 최근에 set된 값을 가져올 수 있다.
- e.g. 버퍼 처럼 임시로 사용할 객체를 매번 새로 생성하는 대신, 이미 만들어진 객체를 재활용하고자 할 때 많이 쓰인다.
- 개념적으로 Map<Thread, T> 타입으로 생각할 수 있다.
- 전역 변수가 아니면서도 전역 변수처럼 동작하므로 오용에 주의하자.

## 불변성 (immutablity)

- 객체의 상태가 변하지 않는다면? 지금까지 봤던 복잡하고도 다양한 문제가 일순에 사라진다!
- 🌟 불변 객체는 언제라도 스레드에 안전하다.
- 객체 불변과 참조 불변은 구분해서 생각하자. 데이터가 불변 객체에 들어있다고 해도, final이 아니면 다른 불변 객체로 참조를 바꿀 수 있다. 프로그램의 데이터가 언제든지 바뀌는 셈

### final 변수

- 변수의 값을 변경할 수 없다.
- 초기화 안정성을 보장한다. 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있다.

### 불변 객체를 공개할 때 volatile 키워드 사용

- 경쟁 조건을 만드는 여러 변수를 모두 모아 하나의 불변 객체로 관리하면? 경쟁 조건을 방지할 수 있다.

## 안전 공개

- 특정 데이터를 여러 개의 스레드에서 사용하도록 공유할 때 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높다.

### 불변 객체와 초기화 안정성

- 🌟 불변 객체는 별다른 동기화 적용하지 않아도, 어느 스레드건 마음껏 안전하게 사용할 수 있다.

### 안전한 공개 방법의 특성

- 불변 객체가 아닌 객체는 올바른 방법으로 안전하게 공개해야 한다.
- 공개하는 스레드, 사용하는 스레드 양쪽 모두에 동기화 방법을 적용
- 안전하게 공개? → 객체 참조 및 내부의 상태를 외부 스레드도 동시에 볼 수 있어야한다.
    - 객체 참조를 static 메소드에서 초기화
    - 객체 참조를 volatile or AtomicReference 클래스에 보관
    - 객체 참조를 올바르게 생성된 클래스 내부 final 변수에 보관
    - 락을 사용해 올바르게 막혀 있는 변수에 객체 참조 보관 (스레드 세이프한 API)
- 스레드 동기화 기능 갖고 있는 API
    - Hashtable, ConcurrentMap ... 스레드 안전한 맵, 키 값
    - Vector, CopyOnWriteArrayList, CopyOnWriteArraySet … 스레드 안전한 컬렉션
    - BlokcingQueue, ConcurrentLinkedQueue …

### 결과적으로 불변인 객체

- 불변 객체를 다시 찬양하자면….
    - 특정 객체를 안전한 방법으로 공개했을 경우
    - 객체에 대한 참조를 갖고 객체를 불러와 사용하는 시점에는 공개하는 시점의 객체 상태를 정확하게 사용할 수 있고,
    - 값이 바뀌지 않는 한 여러 스레드에서 동시에 값을 가져다 사용해도 동기화 문제가 없다.
- 불변 객체인 것처럼 사용하면 동기화 작업을 하지 않아도 된다.

### 가변 객체

- mutable object를 사용할 때는 공개하는 부분, 가변 객체를 사용하는 모든 부분에 동기화 코드를 작성해야한다.
- 🌟 가변성에 따라 객체를 공개할 때 필요한 점
    - 불변 객체 → 어떤 방법으로 공개해도 문제 없음
    - 결과적 불변 객체 → 안전하게 공개하자
    - 가변 객체 → 안전하게 공개 & 스레드 안전하게 만들거나 & 락으로 동기화 필요.

### 객체를 안전하게 공유하기

- 객체를 사용하기 전에 고려할 거
    - 동기화 코드를 적용해 락을 확보해야 하나?
    - 객체 내부 값을 바꿔도 괜찮나?
    - 값을 읽기만 해야하나?
- 객체를 공개할 때
    - 해당 객체를 어떤 방법으로 사용할 수 있고, 사용해야 하는지에 대해 정확한 설명 필요

## 🌟 병렬 프로그램에서 객체 공유 원칙

### 스레드 한정

- 스레드 한정 객체는 완전하게 해당 스레드 내부에만 존재 및 그 스레드만 호출 사용 가능

### 읽기 전용 객체 공유

- 불변 객체와 결과적 불변 객체를 포함한다.
- 별다른 동기화 작업 없이도 여러 스레드에서 마음껏 사용가능

### 스레드 안전 객체 공유

- 객체 내부적으로 필수 동기화 기능이 있으니 외부에서 신경쓸 필요 없다. 여러 스레드에서 마음껏 사용

### 동기화 방법 적용

- 객체 접근을 위해 락 획득을 기다린다.